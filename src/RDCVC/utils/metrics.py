"""
* This file contains functions for calculating metrics and printing them for CCPmodel.
*
* File: metrics.py
* Author: Fan Kai
* Soochow University
* Created: 2023-10-04 11:14:11
* ----------------------------
* Modified: 2023-12-02 04:56:05
* Modified By: Fan Kai
* ========================================================================
* HISTORY:
"""

import numpy as np
from rich import box
from rich import console as Rconsle
from rich import table as Rtable
from sklearn.metrics import make_scorer
from sklearn.metrics import mean_absolute_error as mae
from sklearn.metrics import mean_absolute_percentage_error as mape
from sklearn.metrics import mean_squared_error as mse


@staticmethod
def _calculate_metrics(pred, label):
    """
    Calculate metrics for the model.

    Args:
        model (Any): Model for prediction.
        pred (np.ndarray)
        label (np.ndarray)

    Returns:
        dict: Dictionary containing the calculated metrics.
    """
    return {
        "MAE": mae(label, pred),
        "MAPE": mape(label, pred),
        "RMSE": np.sqrt(mse(label, pred)),
    }


@staticmethod
def calculate_metrics(
    pred,
    label,
    print_metrics=False,
    output=False,
    title="CCP Predictive Modeling Metrics",
):
    """Calculate metrics for CCPmodel. print the metrics. Return the metrics.

    Example:
        Metric      MAE         MAPE        RMSE
        -------------------------------------------
        Airflow:	60.1669     6.938%      76.0261
        Pres:		4.4783      30.957%     6.7181

    Args:
        model (Any): model for prediction.
        pred (np.ndarray): Prediction.
        label (np.ndarray): Label.
        print_metrics (bool, optional): Whether to print the metrics. Defaults to False.

    Returns:
        dict: Dictionary containing the calculated metrics.
    """
    # split
    _label_airflow = label[:, :4]
    _pred_airflow = pred[:, :4]
    _label_pres = label[:, 4:]
    _pred_pres = pred[:, 4:]

    metrics = {
        "MAE": {
            "Airflow": mae(_label_airflow, _pred_airflow),
            "Pres": mae(_label_pres, _pred_pres),
        },
        "MAPE": {
            "Airflow": mape(_label_airflow, _pred_airflow),
            "Pres": mape(_label_pres, _pred_pres),
        },
        "RMSE": {
            "Airflow": np.sqrt(mse(_label_airflow, _pred_airflow)),
            "Pres": np.sqrt(mse(_label_pres, _pred_pres)),
        },
    }
    print_ccp_metrics(metrics, title) if print_metrics else None
    return metrics if output else None


def print_ccp_metrics(metrics, title):
    """
    Prints CCP Predictive Modeling Metrics.

    Args:
        metrics (dict): A dictionary containing the metrics data.

    Example:
        Metric      MAE         MAPE        RMSE
        -------------------------------------------
        Airflow:	60.1669     6.938%      76.0261
        Pres:		4.4783      30.957%     6.7181

    metrics example: {
        "MAE": {
            "Airflow": 60.1669,
            "Pres": 4.4783,
        },
        "MAPE": {
            "Airflow": 6.938,
            "Pres": 30.957,
        },
        "RMSE": {
            "Airflow": 76.0261,
            "Pres": 6.7181,
        },
    }

    Returns:
        None
    """
    airflow_data = (
        "Airflow",
        f"{metrics['MAE']['Airflow']:.2f}",
        f"{metrics['MAPE']['Airflow'] * 100:.2f}%",
        f"{metrics['RMSE']['Airflow']:.2f}",
    )
    pres_data = (
        "Pres",
        f"{metrics['MAE']['Pres']:.2f}",
        f"{metrics['MAPE']['Pres'] * 100:.2f}%",
        f"{metrics['RMSE']['Pres']:.2f}",
    )

    console = Rconsle.Console()
    table = Rtable.Table(title=title, show_header=True, box=box.HEAVY_EDGE)
    table.add_column("Feature", style="dim")
    table.add_column("MAE(Pa)", justify="center")
    table.add_column("MAPE", justify="center")
    table.add_column("RMSE(Pa)", justify="center")
    table.add_row(*airflow_data)
    table.add_row(*pres_data)
    console.print(table)


def print_results_table(
    results,
    ccp_scoring,
    k=5,
    title="CCP Predictive Modeling Results",
    show_time_cost=False,
):
    """
    Prints a table summarizing the results and metrics.

    <results> generated by sklearn.model_selection.cross_validate

    Args:
        results (dict): A dictionary containing the results of the evaluation.
        ccp_scoring (list): A list of metrics to be included in the table.
        k (int, optional): The number of folds. Defaults to 5.

    Returns:
        None

    """
    # sourcery skip: extract-duplicate-method, extract-method
    k = k  # number of folds
    console = Rconsle.Console()

    # Create a table
    table = Rtable.Table(
        title=title, show_header=True, header_style="bold white on blue"
    )
    table.add_column("Metric")
    table.add_column("Mean")
    for fold in range(1, k + 1):
        table.add_column(f"Fold {fold}")

    # Add rows to the table
    for metric in ccp_scoring:
        row = [metric, f"{results[f'test_{metric}'].mean():.2f}"]
        row.extend(
            f"{results[f'test_{metric}'][fold - 1]:.2f}" for fold in range(1, k + 1)
        )
        table.add_row(*row)

    console.print(table)

    if show_time_cost:
        # Print the mean fit time and score time
        mean_fit_time = results["fit_time"].mean()
        mean_score_time = results["score_time"].mean()
        time_table = Rtable.Table(show_header=True, header_style="bold white on blue")
        time_table.add_column("Mean Fit Time")
        time_table.add_column("Mean Score Time")
        time_table.add_row(f"{mean_fit_time}", f"{mean_score_time}")
        console.print(time_table)


# -------------------------------------------------------- #
#                       sklearn score                      #
# -------------------------------------------------------- #


def get_ccp_scoring():
    """
    Returns a dictionary of scoring functions for evaluating performance in a CCP model.

    Returns:
        dict: A dictionary containing the following scoring functions:
            - 'score': Integrated scoring function that combines
                Mean Squared Error (MSE) for airflow and pressure predictions.
            - 'airflow_rmse': Root Mean Squared Error (RMSE) for airflow predictions.
            - 'pres_rmse': RMSE for pressure predictions.
    """

    def integrated_scoring(y_true, y_pred):
        mse_airflow = mse(y_true[:, :4], y_pred[:, :4])
        mse_pres = mse(y_true[:, 4:], y_pred[:, 4:])
        return 0.05 * mse_airflow + 0.5 * mse_pres

    def airflow_rmse(y_true, y_pred):
        return mse(y_true[:, :4], y_pred[:, :4], squared=False)

    def airflow_mae(y_true, y_pred):
        return mae(y_true[:, :4], y_pred[:, :4])

    def pres_rmse(y_true, y_pred):
        return mse(y_true[:, 4:], y_pred[:, 4:], squared=False)

    def pres_mae(y_true, y_pred):
        return mae(y_true[:, 4:], y_pred[:, 4:])

    _integrated_scorer = make_scorer(integrated_scoring, greater_is_better=False)
    _airflow_mae_scorer = make_scorer(airflow_mae, greater_is_better=False)
    _airflow_rmse_scorer = make_scorer(airflow_rmse, greater_is_better=False)
    _pres_mae_scorer = make_scorer(pres_mae, greater_is_better=False)
    _pres_rmse_scorer = make_scorer(pres_rmse, greater_is_better=False)

    ccp_scoring = {
        "score": _integrated_scorer,
        "airflow_mae": _airflow_mae_scorer,
        "airflow_rmse": _airflow_rmse_scorer,
        "pres_mae": _pres_mae_scorer,
        "pres_rmse": _pres_rmse_scorer,
    }

    return ccp_scoring


if __name__ == "__main__":
    metrics = {
        "MAE": {
            "Airflow": 60.1669,
            "Pres": 4.4783,
        },
        "MAPE": {
            "Airflow": 6.938,
            "Pres": 30.957,
        },
        "RMSE": {
            "Airflow": 76.0261,
            "Pres": 6.7181,
        },
    }
    print_ccp_metrics(metrics, title="sss")
